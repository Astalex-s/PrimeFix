# Безопасный стек для сбора заявок (на базе Docker)

Этот стек предоставляет безопасную, изолированную среду для сбора заявок от теплых клиентов.  
Все данные клиентов предназначены для хранения строго на одном сервере.

В состав стека входят:
- Nginx (обратный прокси, единственная точка входа в веб-приложение)
- PostgreSQL (хранилище данных, не проброшено наружу из Docker)
- pgAdmin (веб-интерфейс для администрирования PostgreSQL)
- Локальный Docker Registry (для образов бэкенда, с аутентификацией по htpasswd)
- Watchtower (автоматическое отслеживание и обновление образов)
- Сервис бэкенда (только плейсхолдер, пока не реализован и не включен)

> Фронтенд и бэкенд как приложение **не реализованы** в этом репозитории.  
> Здесь описана только инфраструктура и базовая структура проекта.

---

## 1. Предварительные требования

- Docker с поддержкой API не ниже **1.44** (иначе возможна ошибка «client version 1.25 is too old»).
- Docker Compose (рекомендуется v2+ с командой `docker compose`).

Все команды нужно выполнять из корня репозитория (где находится файл `docker-compose.yml`).

### Обновление Docker до нужной версии

Если при запуске появляется ошибка про API version 1.44, обновите Docker:

- **Ubuntu/Debian:** выполните скрипт от root:
  ```bash
  sudo bash scripts/upgrade-docker.sh
  ```
- Убедитесь, что не задана старая версия API: `unset DOCKER_API_VERSION`.
- Перезапустите демон при необходимости: `sudo systemctl restart docker`.

---

## 2. Запуск и остановка стека

### Запуск стека

При первом запуске или если образы не подтянулись, сначала скачайте их:

```bash
docker compose pull
```

Затем запустите все сервисы:

```bash
docker compose up -d
```

Будут запущены:
- `nginx` (доступен на порту `80`)
- `registry` (доступен на порту `5000`)
- `pgadmin` (доступен на порту `5050`)
- `postgres` (без проброса портов на хост)
- `watchtower`

### Остановка стека

```bash
docker compose down
```

### Остановка и удаление контейнеров/сетей **без удаления данных**

```bash
docker compose down
```

Именованные тома `postgres_data` и `registry_data` будут сохранены.

### Остановка и удаление всего, **включая данные**

```bash
docker compose down -v
```

Эта команда удалит тома `postgres_data` и `registry_data`.

---

## 3. Локальный Docker Registry (с аутентификацией htpasswd)

Локальный Docker Registry доступен по адресу:

- `http://<имя-хоста-или-ip-сервера>:5000`

Данные реестра хранятся в именованном Docker-томе и не покидают сервер.

### 3.1. Создание учетных данных `htpasswd`

Реестр настроен на использование файла `htpasswd`, расположенного по пути:

- `./registry/auth/htpasswd` (на хосте)

Этот файл необходимо создать **до** выполнения входа (`docker login`) или отправки образов (`docker push`).

#### Вариант A – Утилита `htpasswd` на хосте

Если `htpasswd` установлен на вашем хосте:

```bash
mkdir -p registry/auth
htpasswd -B -c registry/auth/htpasswd myuser
```

Утилита запросит ввод пароля для пользователя `myuser`.

#### Вариант B – Использование Docker-контейнера (если `htpasswd` не установлен на хосте)

Если на хосте нет `htpasswd`, файл можно создать с помощью временного Docker-контейнера:

```bash
mkdir -p registry/auth
docker run --rm \
  httpd:2.4-alpine \
  htpasswd -Bbn myuser mypassword > registry/auth/htpasswd
```

Эта команда создаст файл `registry/auth/htpasswd` с пользователем `myuser` и паролем `mypassword`.

> Эту команду можно повторять с другими именами пользователей и паролями.  
> В реальной среде используйте сложные и уникальные пароли.

### 3.2. Перезапуск стека после создания `htpasswd`

Если реестр уже был запущен к моменту создания `htpasswd`, перезапустите стек:

```bash
docker compose down
docker compose up -d
```

---

## 4. Вход в локальный реестр

После создания файла `htpasswd` и запуска стека выполните вход с вашей машины:

```bash
docker login <имя-хоста-или-ip-сервера>:5000 -u myuser -p mypassword
```

Примеры:

```bash
# Если Docker запущен локально на этой же машине:
docker login localhost:5000 -u myuser -p mypassword

# Если реестр расположен на удаленном сервере:
docker login my.server.example.com:5000 -u myuser -p mypassword
```

После успешного входа Docker-клиент сохранит учетные данные локально, и вы сможете отправлять (`push`) и получать (`pull`) образы.

---

## 5. Отправка образов бэкенда в локальный реестр

Локальный реестр предназначен для хранения образов бэкенда.

### 5.1. Сборка образа бэкенда локально

В вашем проекте бэкенда (который не входит в этот репозиторий) выполните:

```bash
docker build -t backend-image:latest .
```

Вы можете использовать любое имя образа; `backend-image:latest` — это лишь пример.

### 5.2. Тегирование образа для локального реестра

Назначьте образу тег, указывающий на локальный реестр (порт 5000):

```bash
docker tag backend-image:latest <имя-хоста-или-ip-сервера>:5000/backend:latest
```

Примеры:

```bash
docker tag backend-image:latest localhost:5000/backend:latest
```

### 5.3. Отправка образа в реестр

```bash
docker push <имя-хоста-или-ip-сервера>:5000/backend:latest
```

Пример:

```bash
docker push localhost:5000/backend:latest
```

После отправки образ будет сохранен на сервере (в томе `registry_data`).

---

## 6. Использование образа из реестра для сервиса бэкенда

В файле `docker-compose.yml` уже есть **закомментированный** плейсхолдер для сервиса бэкенда.

Когда вы будете готовы реализовать бэкенд:

1. Убедитесь, что образ отправлен в локальный реестр, например:
   - `localhost:5000/backend:latest`
2. Отредактируйте `docker-compose.yml`:
   - Раскомментируйте секцию сервиса `backend`.
   - Установите поле `image` в значение вашего образа (например, `localhost:5000/backend:latest`).
   - Настройте переменные окружения для подключения к PostgreSQL, если требуется.
3. Перезапустите стек:

```bash
docker compose up -d --build
```

Nginx уже настроен на проксирование API-запросов по пути `/api/` к сервису `backend` (по имени сервиса в сети Docker).

---

## 7. Доступ к pgAdmin и PostgreSQL

### 7.1. pgAdmin

- URL: `http://<имя-хоста-или-ip-сервера>:5050`
- Стандартные учетные данные (из `docker-compose.yml`):
  - Email: `admin@example.com`
  - Password: `change_me`

Перед использованием pgAdmin в любой среде, отличной от локальной разработки, рекомендуется изменить эти значения в `docker-compose.yml`.

### 7.2. Подключение к PostgreSQL из pgAdmin

Создайте новый сервер в pgAdmin со следующими параметрами:

- **Host**: `postgres`
- **Port**: `5432`
- **Maintenance database**: `app_db`
- **Username**: `app_user`
- **Password**: `change_me`

Эти значения заданы в переменных окружения сервиса `postgres` в `docker-compose.yml` и доступны только внутри внутренней Docker-сети.

---

## 8. Заметки по безопасности

- PostgreSQL **не** проброшен на порты хоста.
- Сервис бэкенда (после включения) **не должен** пробрасывать порты на хост; доступ к нему осуществляется только через Nginx во внутренней сети Docker.
- Наружу проброшены только следующие порты:
  - `80` → Nginx
  - `5000` → Docker Registry
  - `5050` → pgAdmin
- Данные клиентов предназначены для хранения только на этом сервере; внешние базы данных и внешние сервисы хранения данных в этой конфигурации не используются.

---

## 9. Устранение неполадок

### Nginx не стартует: «host not found in upstream "backend"»

Конфигурация Nginx настроена так, что резолвинг `backend` выполняется при запросе, а не при старте. Nginx должен запускаться даже без контейнера backend. Если ошибка всё же появляется, проверьте, что в `nginx/conf.d/default.conf` используется `resolver 127.0.0.11` и `proxy_pass http://$backend_ups`.

### Watchtower: «client version 1.25 is too old. Minimum supported API version is 1.44»

Демон Docker на хосте требует API 1.44+, а образ Watchtower может содержать старый клиент. Сделано:

- В `docker-compose.yml` указан образ `containrrr/watchtower:1.8.2`. Выполните `docker compose pull watchtower` и снова `docker compose up -d`.
- Если ошибка сохраняется, временно отключите Watchtower: закомментируйте сервис `watchtower` в `docker-compose.yml` и запустите стек без него. Остальные сервисы от этого не пострадают.

